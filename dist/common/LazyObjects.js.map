{"version":3,"file":"LazyObjects.js","sourceRoot":"","sources":["../../src/common/LazyObjects.ts"],"names":[],"mappings":"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","sourcesContent":["const DirtySymbol = Symbol(\"dirty\");\n\nexport const LazyObjects = <T extends object>() => {\n  let suppressDirty = false;\n  let suppressLazy = false;\n  type LazyObjectType = \"array\" | \"object\";\n  type LazyObject<T> = T & {\n    [DirtySymbol]: boolean;\n  };\n\n  const createLazyObject = (type: LazyObjectType = \"object\"): LazyObject<T> => {\n    const root: any = type == \"object\" ? {} : [];\n    Object.defineProperty(root, DirtySymbol, {\n      value: false,\n      writable: true,\n      enumerable: false,\n      configurable: false,\n    });\n\n    return new Proxy(root, {\n      get(target, prop, receiver) {\n        if (prop === DirtySymbol) {\n          return target[DirtySymbol];\n        }\n\n        if (prop === \"toJSON\") {\n          return function () {\n            const out: any = {};\n            for (const key of Object.keys(target)) {\n              const val = target[key];\n              if (\n                val &&\n                typeof val === \"object\" &&\n                typeof val.toJSON === \"function\"\n              ) {\n                out[key] = val.toJSON();\n              } else {\n                out[key] = val;\n              }\n            }\n            return out;\n          };\n        }\n        if (prop === Symbol.toStringTag) {\n          return undefined;\n        }\n\n        if (!(prop in target) && !suppressLazy) {\n          target[prop] = createLazyObject();\n        }\n\n        return Reflect.get(target, prop, receiver);\n      },\n\n      set(target, prop, value, receiver) {\n        if (prop !== DirtySymbol && !suppressDirty) {\n          target[DirtySymbol] = true;\n        }\n        return Reflect.set(target, prop, value, receiver);\n      },\n\n      has(target, prop) {\n        // Avoid triggering lazy init during `prop in obj`\n        return Reflect.has(target, prop);\n      },\n\n      ownKeys(target) {\n        // Prevent keys from being listed unless explicitly created\n        return Reflect.ownKeys(target);\n      },\n\n      getOwnPropertyDescriptor(target, prop) {\n        return Object.getOwnPropertyDescriptor(target, prop);\n      },\n    });\n  };\n\n  const isDirty = (obj: any): boolean => {\n    if (obj[DirtySymbol]) {\n      return obj[DirtySymbol];\n    }\n    for (const key in obj) {\n      if (obj[key] && typeof obj[key] === \"object\") {\n        return isDirty(obj[key]);\n      }\n    }\n    return false;\n  };\n\n  const wrapLazyObject = <T extends object>(obj: Partial<T>): LazyObject<T> => {\n    const type = Array.isArray(obj) ? \"array\" : \"object\";\n    const lazy: any = createLazyObject(type);\n\n    for (const [key, value] of Object.entries(obj)) {\n      if (value === undefined) {\n        continue;\n      }\n      if (value === null) {\n        lazy[key] = null;\n        continue;\n      }\n      lazy[key] =\n        typeof value === \"object\" ? wrapLazyObject(value as any) : value;\n    }\n\n    return lazy;\n  };\n  const from = (obj?: Partial<T>): LazyObject<T> => {\n    if (obj === undefined) {\n      return createLazyObject();\n    }\n    suppressDirty = true;\n    const lazy = wrapLazyObject(obj);\n    suppressDirty = false;\n    return lazy;\n  };\n  const setSuppressDirty = (suppress: boolean) => {\n    suppressDirty = suppress;\n  };\n  const setSuppressLazy = (suppress: boolean) => {\n    suppressLazy = suppress;\n  };\n\n  const toPlain = <T extends object>(obj: LazyObject<T>): T => {\n    return JSON.parse(JSON.stringify(obj));\n  };\n  return {\n    isDirty,\n    from,\n    setSuppressDirty,\n    setSuppressLazy,\n    toPlain,\n  };\n};\n"]}
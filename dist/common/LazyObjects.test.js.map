{"version":3,"file":"LazyObjects.test.js","sourceRoot":"","sources":["../../src/common/LazyObjects.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, expect, test } from \"vitest\";\nimport { LazyObjects } from \"./LazyObjects\";\nimport { Component } from \"../type/Component\";\nimport { Entity } from \"../type/Entity\";\n\ndescribe(\"LazyObjects\", () => {\n  type IdComponent = Component<\"core\", \"id\", number>;\n\n  type PositionComponent = Component<\n    \"world\",\n    \"position\",\n    { x: number; y: number; z?: number }\n  >;\n  type HealthComponent = Component<\"stats\", \"health\", number>;\n  type TagsComponent = Component<\"core\", \"tags\", string[]>;\n\n  type MyEntity = Entity<\n    [IdComponent, PositionComponent, HealthComponent, TagsComponent]\n  >;\n  const lazy = LazyObjects();\n\n  test(\"from empty\", () => {\n    const testEntity: MyEntity = lazy.from<MyEntity>();\n\n    testEntity.core.id = 1;\n\n    testEntity.world.position = {\n      x: 1,\n      y: 2,\n    };\n    expect(testEntity.world.position).toEqual({\n      x: 1,\n      y: 2,\n      z: undefined,\n    });\n  });\n\n  test(\"dirty\", () => {\n    const testEntity: MyEntity = lazy.from<MyEntity>();\n\n    expect(lazy.isDirty(testEntity)).toBe(false);\n    testEntity.core.id = 1;\n    const foo = testEntity.core.id;\n    expect(lazy.isDirty(testEntity)).toBe(true);\n  });\n  test(\"keys\", () => {\n    const testEntity: MyEntity = lazy.from<MyEntity>();\n    testEntity.core.id = 1;\n    testEntity.world.position = {\n      x: 1,\n      y: 2,\n    };\n    const keys = Object.keys(testEntity);\n    expect(keys).toEqual([\"core\", \"world\"]);\n  });\n  test(\"stringify\", () => {\n    const testEntity: MyEntity = lazy.from<MyEntity>();\n    testEntity.core.id = 1;\n    testEntity.world.position = {\n      x: 1,\n      y: 2,\n    };\n    const stringified = JSON.stringify(testEntity);\n    expect(stringified).toBe(\n      '{\"core\":{\"id\":1},\"world\":{\"position\":{\"x\":1,\"y\":2}}}'\n    );\n  });\n  test(\"arrays\", () => {\n    const testEntity: MyEntity = lazy.from<MyEntity>();\n    testEntity.core.tags = [\"tag1\", \"tag2\"];\n    expect(testEntity.core.tags).toEqual([\"tag1\", \"tag2\"]);\n  });\n  test(\"from existing\", () => {\n    const testEntity: MyEntity = lazy.from<MyEntity>({\n      core: {\n        id: 1,\n        tags: [\"tag1\", \"tag2\"],\n      },\n    });\n    expect(lazy.isDirty(testEntity)).toBe(false);\n    expect(testEntity.core.tags).toEqual([\"tag1\", \"tag2\"]);\n  });\n});\n"]}